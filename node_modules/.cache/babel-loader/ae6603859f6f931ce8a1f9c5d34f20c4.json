{"ast":null,"code":"'use strict';\n\nconst prompts = require('./prompts');\n\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];\n\nconst noop = () => {};\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\n\n\nasync function prompt(questions = [], {\n  onSubmit = noop,\n  onCancel = noop\n} = {}) {\n  const answers = {};\n  const override = prompt._override || {};\n  questions = [].concat(questions);\n  let answer, question, quit, name, type, lastPrompt;\n\n  const getFormattedAnswer = async (question, answer, skipValidation = false) => {\n    if (!skipValidation && question.validate && question.validate(answer) !== true) {\n      return;\n    }\n\n    return question.format ? await question.format(answer, answers) : answer;\n  };\n\n  for (question of questions) {\n    var _question = question;\n    name = _question.name;\n    type = _question.type;\n\n    // evaluate type first and skip if type is a falsy value\n    if (typeof type === 'function') {\n      type = await type(answer, { ...answers\n      }, question);\n      question['type'] = type;\n    }\n\n    if (!type) continue; // if property is a function, invoke it unless it's a special function\n\n    for (let key in question) {\n      if (passOn.includes(key)) continue;\n      let value = question[key];\n      question[key] = typeof value === 'function' ? await value(answer, { ...answers\n      }, lastPrompt) : value;\n    }\n\n    lastPrompt = question;\n\n    if (typeof question.message !== 'string') {\n      throw new Error('prompt message is required');\n    } // update vars in case they changed\n\n\n    var _question2 = question;\n    name = _question2.name;\n    type = _question2.type;\n\n    if (prompts[type] === void 0) {\n      throw new Error(`prompt type (${type}) is not defined`);\n    }\n\n    if (override[question.name] !== undefined) {\n      answer = await getFormattedAnswer(question, override[question.name]);\n\n      if (answer !== undefined) {\n        answers[name] = answer;\n        continue;\n      }\n    }\n\n    try {\n      // Get the injected answer if there is one or prompt the user\n      answer = prompt._injected ? getInjectedAnswer(prompt._injected) : await prompts[type](question);\n      answers[name] = answer = await getFormattedAnswer(question, answer, true);\n      quit = await onSubmit(question, answer, answers);\n    } catch (err) {\n      quit = !(await onCancel(question, answers));\n    }\n\n    if (quit) return answers;\n  }\n\n  return answers;\n}\n\nfunction getInjectedAnswer(injected) {\n  const answer = injected.shift();\n\n  if (answer instanceof Error) {\n    throw answer;\n  }\n\n  return answer;\n}\n\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\n\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\n\nmodule.exports = Object.assign(prompt, {\n  prompt,\n  prompts,\n  inject,\n  override\n});","map":{"version":3,"sources":["/home/vinicius/Desktop/Projects/sd-011-project-trivia-react-redux/node_modules/prompts/lib/index.js"],"names":["prompts","require","passOn","noop","prompt","questions","onSubmit","onCancel","answers","override","_override","concat","answer","question","quit","name","type","lastPrompt","getFormattedAnswer","skipValidation","validate","format","key","includes","value","message","Error","undefined","_injected","getInjectedAnswer","err","injected","shift","inject","Object","assign","module","exports"],"mappings":"AAAA;;AAEA,MAAMA,OAAO,GAAGC,OAAO,CAAC,WAAD,CAAvB;;AAEA,MAAMC,MAAM,GAAG,CAAC,SAAD,EAAY,QAAZ,EAAsB,SAAtB,EAAiC,UAAjC,EAA6C,UAA7C,EAAyD,MAAzD,CAAf;;AACA,MAAMC,IAAI,GAAG,MAAM,CAAE,CAArB;AAEA;;;;;;;;;AAOA,eAAeC,MAAf,CAAsBC,SAAS,GAAC,EAAhC,EAAoC;AAAEC,EAAAA,QAAQ,GAACH,IAAX;AAAiBI,EAAAA,QAAQ,GAACJ;AAA1B,IAAiC,EAArE,EAAyE;AACvE,QAAMK,OAAO,GAAG,EAAhB;AACA,QAAMC,QAAQ,GAAGL,MAAM,CAACM,SAAP,IAAoB,EAArC;AACAL,EAAAA,SAAS,GAAG,GAAGM,MAAH,CAAUN,SAAV,CAAZ;AACA,MAAIO,MAAJ,EAAYC,QAAZ,EAAsBC,IAAtB,EAA4BC,IAA5B,EAAkCC,IAAlC,EAAwCC,UAAxC;;AAEA,QAAMC,kBAAkB,GAAG,OAAOL,QAAP,EAAiBD,MAAjB,EAAyBO,cAAc,GAAG,KAA1C,KAAoD;AAC7E,QAAI,CAACA,cAAD,IAAmBN,QAAQ,CAACO,QAA5B,IAAwCP,QAAQ,CAACO,QAAT,CAAkBR,MAAlB,MAA8B,IAA1E,EAAgF;AAC9E;AACD;;AACD,WAAOC,QAAQ,CAACQ,MAAT,GAAkB,MAAMR,QAAQ,CAACQ,MAAT,CAAgBT,MAAhB,EAAwBJ,OAAxB,CAAxB,GAA2DI,MAAlE;AACD,GALD;;AAOA,OAAKC,QAAL,IAAiBR,SAAjB,EAA4B;AAAA,oBACRQ,QADQ;AACvBE,IAAAA,IADuB,aACvBA,IADuB;AACjBC,IAAAA,IADiB,aACjBA,IADiB;;AAG1B;AACA,QAAI,OAAOA,IAAP,KAAgB,UAApB,EAAgC;AAC9BA,MAAAA,IAAI,GAAG,MAAMA,IAAI,CAACJ,MAAD,EAAS,EAAE,GAAGJ;AAAL,OAAT,EAAyBK,QAAzB,CAAjB;AACAA,MAAAA,QAAQ,CAAC,MAAD,CAAR,GAAmBG,IAAnB;AACD;;AACD,QAAI,CAACA,IAAL,EAAW,SARe,CAU1B;;AACA,SAAK,IAAIM,GAAT,IAAgBT,QAAhB,EAA0B;AACxB,UAAIX,MAAM,CAACqB,QAAP,CAAgBD,GAAhB,CAAJ,EAA0B;AAC1B,UAAIE,KAAK,GAAGX,QAAQ,CAACS,GAAD,CAApB;AACAT,MAAAA,QAAQ,CAACS,GAAD,CAAR,GAAgB,OAAOE,KAAP,KAAiB,UAAjB,GAA8B,MAAMA,KAAK,CAACZ,MAAD,EAAS,EAAE,GAAGJ;AAAL,OAAT,EAAyBS,UAAzB,CAAzC,GAAgFO,KAAhG;AACD;;AAEDP,IAAAA,UAAU,GAAGJ,QAAb;;AAEA,QAAI,OAAOA,QAAQ,CAACY,OAAhB,KAA4B,QAAhC,EAA0C;AACxC,YAAM,IAAIC,KAAJ,CAAU,4BAAV,CAAN;AACD,KArByB,CAuB1B;;;AAvB0B,qBAwBRb,QAxBQ;AAwBvBE,IAAAA,IAxBuB,cAwBvBA,IAxBuB;AAwBjBC,IAAAA,IAxBiB,cAwBjBA,IAxBiB;;AA0B1B,QAAIhB,OAAO,CAACgB,IAAD,CAAP,KAAkB,KAAK,CAA3B,EAA8B;AAC5B,YAAM,IAAIU,KAAJ,CAAW,gBAAeV,IAAK,kBAA/B,CAAN;AACD;;AAED,QAAIP,QAAQ,CAACI,QAAQ,CAACE,IAAV,CAAR,KAA4BY,SAAhC,EAA2C;AACzCf,MAAAA,MAAM,GAAG,MAAMM,kBAAkB,CAACL,QAAD,EAAWJ,QAAQ,CAACI,QAAQ,CAACE,IAAV,CAAnB,CAAjC;;AACA,UAAIH,MAAM,KAAKe,SAAf,EAA0B;AACxBnB,QAAAA,OAAO,CAACO,IAAD,CAAP,GAAgBH,MAAhB;AACA;AACD;AACF;;AAED,QAAI;AACF;AACAA,MAAAA,MAAM,GAAGR,MAAM,CAACwB,SAAP,GAAmBC,iBAAiB,CAACzB,MAAM,CAACwB,SAAR,CAApC,GAAyD,MAAM5B,OAAO,CAACgB,IAAD,CAAP,CAAcH,QAAd,CAAxE;AACAL,MAAAA,OAAO,CAACO,IAAD,CAAP,GAAgBH,MAAM,GAAG,MAAMM,kBAAkB,CAACL,QAAD,EAAWD,MAAX,EAAmB,IAAnB,CAAjD;AACAE,MAAAA,IAAI,GAAG,MAAMR,QAAQ,CAACO,QAAD,EAAWD,MAAX,EAAmBJ,OAAnB,CAArB;AACD,KALD,CAKE,OAAOsB,GAAP,EAAY;AACZhB,MAAAA,IAAI,GAAG,EAAE,MAAMP,QAAQ,CAACM,QAAD,EAAWL,OAAX,CAAhB,CAAP;AACD;;AAED,QAAIM,IAAJ,EAAU,OAAON,OAAP;AACX;;AAED,SAAOA,OAAP;AACD;;AAED,SAASqB,iBAAT,CAA2BE,QAA3B,EAAqC;AACnC,QAAMnB,MAAM,GAAGmB,QAAQ,CAACC,KAAT,EAAf;;AACE,MAAIpB,MAAM,YAAYc,KAAtB,EAA6B;AAC3B,UAAMd,MAAN;AACD;;AAED,SAAOA,MAAP;AACH;;AAED,SAASqB,MAAT,CAAgBzB,OAAhB,EAAyB;AACvBJ,EAAAA,MAAM,CAACwB,SAAP,GAAmB,CAACxB,MAAM,CAACwB,SAAP,IAAoB,EAArB,EAAyBjB,MAAzB,CAAgCH,OAAhC,CAAnB;AACD;;AAED,SAASC,QAAT,CAAkBD,OAAlB,EAA2B;AACzBJ,EAAAA,MAAM,CAACM,SAAP,GAAmBwB,MAAM,CAACC,MAAP,CAAc,EAAd,EAAkB3B,OAAlB,CAAnB;AACD;;AAED4B,MAAM,CAACC,OAAP,GAAiBH,MAAM,CAACC,MAAP,CAAc/B,MAAd,EAAsB;AAAEA,EAAAA,MAAF;AAAUJ,EAAAA,OAAV;AAAmBiC,EAAAA,MAAnB;AAA2BxB,EAAAA;AAA3B,CAAtB,CAAjB","sourcesContent":["'use strict';\n\nconst prompts = require('./prompts');\n\nconst passOn = ['suggest', 'format', 'onState', 'validate', 'onRender', 'type'];\nconst noop = () => {};\n\n/**\n * Prompt for a series of questions\n * @param {Array|Object} questions Single question object or Array of question objects\n * @param {Function} [onSubmit] Callback function called on prompt submit\n * @param {Function} [onCancel] Callback function called on cancel/abort\n * @returns {Object} Object with values from user input\n */\nasync function prompt(questions=[], { onSubmit=noop, onCancel=noop }={}) {\n  const answers = {};\n  const override = prompt._override || {};\n  questions = [].concat(questions);\n  let answer, question, quit, name, type, lastPrompt;\n\n  const getFormattedAnswer = async (question, answer, skipValidation = false) => {\n    if (!skipValidation && question.validate && question.validate(answer) !== true) {\n      return;\n    }\n    return question.format ? await question.format(answer, answers) : answer\n  };\n\n  for (question of questions) {\n    ({ name, type } = question);\n\n    // evaluate type first and skip if type is a falsy value\n    if (typeof type === 'function') {\n      type = await type(answer, { ...answers }, question)\n      question['type'] = type\n    }\n    if (!type) continue;\n\n    // if property is a function, invoke it unless it's a special function\n    for (let key in question) {\n      if (passOn.includes(key)) continue;\n      let value = question[key];\n      question[key] = typeof value === 'function' ? await value(answer, { ...answers }, lastPrompt) : value;\n    }\n\n    lastPrompt = question;\n\n    if (typeof question.message !== 'string') {\n      throw new Error('prompt message is required');\n    }\n\n    // update vars in case they changed\n    ({ name, type } = question);\n\n    if (prompts[type] === void 0) {\n      throw new Error(`prompt type (${type}) is not defined`);\n    }\n\n    if (override[question.name] !== undefined) {\n      answer = await getFormattedAnswer(question, override[question.name]);\n      if (answer !== undefined) {\n        answers[name] = answer;\n        continue;\n      }\n    }\n\n    try {\n      // Get the injected answer if there is one or prompt the user\n      answer = prompt._injected ? getInjectedAnswer(prompt._injected) : await prompts[type](question);\n      answers[name] = answer = await getFormattedAnswer(question, answer, true);\n      quit = await onSubmit(question, answer, answers);\n    } catch (err) {\n      quit = !(await onCancel(question, answers));\n    }\n\n    if (quit) return answers;\n  }\n\n  return answers;\n}\n\nfunction getInjectedAnswer(injected) {\n  const answer = injected.shift();\n    if (answer instanceof Error) {\n      throw answer;\n    }\n\n    return answer;\n}\n\nfunction inject(answers) {\n  prompt._injected = (prompt._injected || []).concat(answers);\n}\n\nfunction override(answers) {\n  prompt._override = Object.assign({}, answers);\n}\n\nmodule.exports = Object.assign(prompt, { prompt, prompts, inject, override });\n"]},"metadata":{},"sourceType":"script"}